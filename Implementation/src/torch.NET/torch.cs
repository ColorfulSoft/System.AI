//****************************************************************************************************
// (C) ColorfulSoft corp., 2019-2022. All Rights reserved.
// This code is available under Apache-2.0 license
//****************************************************************************************************

using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace System.AI
{

    /// <summary>
    /// An open source machine learning framework that accelerates the path from research prototyping to production deployment.
    /// </summary>
    public static unsafe partial class torch
    {

        #region common

        /// <summary>
        /// Current torch version.
        /// </summary>
        public static string __version__
        {

            get;

            private set;

        }

        /// <summary>
        /// Default data type.
        /// </summary>
        private static DType __default_dtype;

        /// <summary>
        /// Default data type.
        /// </summary>
        public static DType default_dtype
        {

            get
            {
                return __default_dtype;
            }

            set
            {
                if(value != DType.@default)
                {
                    __default_dtype = value;
                }
            }

        }

        /// <summary>
        /// Initializes torch before usage.
        /// </summary>
        static torch()
        {
            __version__ = "0.3";
            default_dtype = torch.float32;
        }

        #endregion

        #region dtype

        /// <summary>
        /// 8-bit floating point. Alias for quarter.
        /// </summary>
        public const DType float8     = DType.float8;

        /// <summary>
        /// 8-bit floating point. Alias for float8.
        /// </summary>
        public const DType quarter    = DType.float8;

        /// <summary>
        /// 16-bit floating point. Alias for half.
        /// </summary>
        public const DType float16    = DType.float16;

        /// <summary>
        /// 16-bit floating point. Alias for float16.
        /// </summary>
        public const DType half       = DType.float16;

        /// <summary>
        /// 16-bit google brain floating point.
        /// </summary>
        public const DType bfloat16   = DType.bfloat16;

        /// <summary>
        /// 32-bit floating point. Alias for float.
        /// </summary>
        public const DType float32    = DType.float32;

        /// <summary>
        /// 32-bit floating point. Alias for float32.
        /// </summary>
        public const DType @float     = DType.float32;

        /// <summary>
        /// 64-bit floating point. Alias for double.
        /// </summary>
        public const DType float64    = DType.float64;

        /// <summary>
        /// 64-bit floating point. Alias for float64.
        /// </summary>
        public const DType @double    = DType.float64;

        /// <summary>
        /// 8-bit complex floating point. Alias for cquarter.
        /// </summary>
        public const DType complex16  = DType.complex16;

        /// <summary>
        /// 8-bit complex floating point. Alias for complex16.
        /// </summary>
        public const DType cquarter   = DType.complex16;

        /// <summary>
        /// 16-bit complex floating point. Alias for chalf.
        /// </summary>
        public const DType complex32  = DType.complex32;

        /// <summary>
        /// 16-bit complex floating point. Alias for complex32.
        /// </summary>
        public const DType chalf      = DType.complex32;

        /// <summary>
        /// 16-bit complex google brain floating point. Alias for cbfloat16.
        /// </summary>
        public const DType bcomplex32 = DType.bcomplex32;

        /// <summary>
        /// 16-bit complex google brain floating point. Alias for bcomplex32.
        /// </summary>
        public const DType cbfloat16  = DType.bcomplex32;

        /// <summary>
        /// 32-bit complex floating point. Alias for cfloat.
        /// </summary>
        public const DType complex64  = DType.complex64;

        /// <summary>
        /// 32-bit complex floating point. Alias for complex64.
        /// </summary>
        public const DType cfloat     = DType.complex64;

        /// <summary>
        /// 64-bit complex floating point. Alias for cdouble.
        /// </summary>
        public const DType complex128 = DType.complex128;

        /// <summary>
        /// 64-bit complex floating point. Alias for complex128.
        /// </summary>
        public const DType cdouble    = DType.complex128;

        /// <summary>
        /// 8-bit signed integer. Alias for sbyte.
        /// </summary>
        public const DType int8       = DType.int8;

        /// <summary>
        /// 8-bit signed integer. Alias for int8.
        /// </summary>
        public const DType @sbyte     = DType.int8;

        /// <summary>
        /// 8-bit unsigned integer. Alias for byte.
        /// </summary>
        public const DType uint8      = DType.uint8;

        /// <summary>
        /// 8-bit unsigned integer. Alias for uint8.
        /// </summary>
        public const DType @byte      = DType.uint8;

        /// <summary>
        /// 16-bit signed integer. Alias for short.
        /// </summary>
        public const DType int16      = DType.int16;

        /// <summary>
        /// 16-bit signed integer. Alias for int16.
        /// </summary>
        public const DType @short     = DType.int16;

        /// <summary>
        /// 16-bit unsigned integer. Alias for ushort.
        /// </summary>
        public const DType uint16     = DType.uint16;

        /// <summary>
        /// 16-bit unsigned integer. Alias for uint16.
        /// </summary>
        public const DType @ushort    = DType.uint16;

        /// <summary>
        /// 32-bit signed integer. Alias for int.
        /// </summary>
        public const DType int32      = DType.int32;

        /// <summary>
        /// 32-bit signed integer. Alias for int32.
        /// </summary>
        public const DType @int       = DType.int32;

        /// <summary>
        /// 32-bit unsigned integer. Alias for uint.
        /// </summary>
        public const DType uint32     = DType.uint32;

        /// <summary>
        /// 32-bit unsigned integer. Alias for uint32
        /// </summary>
        public const DType @uint      = DType.uint32;

        /// <summary>
        /// 64-bit signed integer. Alias for long.
        /// </summary>
        public const DType int64      = DType.int64;

        /// <summary>
        /// 64-bit signed integer. Alias for int64.
        /// </summary>
        public const DType @long      = DType.int64;

        /// <summary>
        /// 64-bit unsigned integer. Alias for ulong.
        /// </summary>
        public const DType uint64     = DType.uint64;

        /// <summary>
        /// 64-bit unsigned integer. Alias for uint64.
        /// </summary>
        public const DType @ulong     = DType.uint64;

        /// <summary>
        /// Boolean.
        /// </summary>
        public const DType @bool      = DType.@bool;

        /// <summary>
        /// Gets the size in bytes occupied by a single value of the dtype data type.
        /// </summary>
        /// <param name="dtype">Data type to test.</param>
        /// <returns>Size in bytes.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int size(this DType dtype)
        {
            dtype = (dtype == DType.@default) ? torch.default_dtype : dtype;
            switch(dtype)
            {
                case torch.float8:
                case torch.int8:
                case torch.uint8:
                case torch.@bool:
                {
                    return 1;
                }
                case torch.float16:
                case torch.bfloat16:
                case torch.complex16:
                case torch.int16:
                case torch.uint16:
                {
                    return 2;
                }
                case torch.float32:
                case torch.complex32:
                case torch.bcomplex32:
                case torch.int32:
                case torch.uint32:
                {
                    return 4;
                }
                case torch.float64:
                case torch.complex64:
                case torch.int64:
                case torch.uint64:
                {
                    return 8;
                }
                case torch.complex128:
                {
                    return 16;
                }
                default:
                {
                    throw new InvalidOperationException("Invalid dtype code.");
                }
            }
        }

        #endregion

        #region device

        /// <summary>
        /// Returns an object of the Device class pointing to the specified device.
        /// </summary>
        /// <param name="device">Device name.</param>
        /// <returns>Device object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Device device(string device)
        {
            return new Device(device);
        }

        #endregion

        #region Tensor ops

        /// <summary>
        /// Returns the number of elements in the tensor.
        /// </summary>
        /// <param name="x">Tensor.</param>
        /// <returns>Number of elements.</returns>
        public static int numel(Tensor x)
        {
            return x.numel;
        }

        #endregion

        #region Tensor tensor(Quarter[*] x, DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of a given data type, copies data from an array of type Quarter to it
        /// by pointer x, interpreting it as multidimensional with dimensions size,
        /// places the tensor on the device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Pointer to array.</param>
        /// <param name="shape">The size of the array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient to the tensor.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter* x, int[] shape, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            if(dtype == DType.@default)
            {
                dtype = torch.float8;
            }
            var t = new Tensor(shape, dtype, device, requires_grad);
            t.device.__backend.convert(x, t.storage);
            return t;
        }

        /// <summary>
        /// Converts a specified standard 0-dimensional array (scalar) of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">System.Quarter value.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            return tensor(&x, null, dtype, device, requires_grad);
        }

        /// <summary>
        /// Converts a specified standard 1-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 2-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 3-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 4-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 5-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 6-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 7-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 8-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 9-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 10-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 11-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 12-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 13-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 14-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 15-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 16-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 17-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 18-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 19-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 20-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 21-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 22-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 23-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 24-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 25-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 26-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 27-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 28-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 29-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 30-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 31-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 32-dimensional array of the Quarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Quarter[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Quarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30),
                                            x.GetLength(31)}, dtype, device, requires_grad);
            }
        }

        #endregion

        #region Tensor tensor(Half[*] x, DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of a given data type, copies data from an array of type Half to it
        /// by pointer x, interpreting it as multidimensional with dimensions size,
        /// places the tensor on the device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Pointer to array.</param>
        /// <param name="shape">The size of the array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient to the tensor.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half* x, int[] shape, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            if(dtype == DType.@default)
            {
                dtype = torch.float16;
            }
            var t = new Tensor(shape, dtype, device, requires_grad);
            t.device.__backend.convert(x, t.storage);
            return t;
        }

        /// <summary>
        /// Converts a specified standard 0-dimensional array (scalar) of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">System.Half value.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            return tensor(&x, null, dtype, device, requires_grad);
        }

        /// <summary>
        /// Converts a specified standard 1-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 2-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 3-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 4-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 5-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 6-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 7-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 8-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 9-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 10-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 11-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 12-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 13-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 14-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 15-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 16-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 17-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 18-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 19-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 20-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 21-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 22-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 23-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 24-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 25-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 26-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 27-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 28-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 29-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 30-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 31-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 32-dimensional array of the Half type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(Half[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(Half* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30),
                                            x.GetLength(31)}, dtype, device, requires_grad);
            }
        }

        #endregion

        #region Tensor tensor(BFloat16[*] x, DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of a given data type, copies data from an array of type BFloat16 to it
        /// by pointer x, interpreting it as multidimensional with dimensions size,
        /// places the tensor on the device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Pointer to array.</param>
        /// <param name="shape">The size of the array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient to the tensor.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16* x, int[] shape, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            if(dtype == DType.@default)
            {
                dtype = torch.bfloat16;
            }
            var t = new Tensor(shape, dtype, device, requires_grad);
            t.device.__backend.convert(x, t.storage);
            return t;
        }

        /// <summary>
        /// Converts a specified standard 0-dimensional array (scalar) of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">System.BFloat16 value.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16 x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            return tensor(&x, null, dtype, device, requires_grad);
        }

        /// <summary>
        /// Converts a specified standard 1-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 2-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 3-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 4-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 5-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 6-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 7-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 8-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 9-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 10-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 11-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 12-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 13-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 14-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 15-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 16-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 17-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 18-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 19-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 20-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 21-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 22-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 23-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 24-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 25-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 26-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 27-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 28-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 29-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 30-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 31-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 32-dimensional array of the BFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(BFloat16[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(BFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30),
                                            x.GetLength(31)}, dtype, device, requires_grad);
            }
        }

        #endregion

        #region Tensor tensor(float[*] x, DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of a given data type, copies data from an array of type float to it
        /// by pointer x, interpreting it as multidimensional with dimensions size,
        /// places the tensor on the device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Pointer to array.</param>
        /// <param name="shape">The size of the array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient to the tensor.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float* x, int[] shape, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            if(dtype == DType.@default)
            {
                dtype = torch.float32;
            }
            var t = new Tensor(shape, dtype, device, requires_grad);
            t.device.__backend.convert(x, t.storage);
            return t;
        }

        /// <summary>
        /// Converts a specified standard 0-dimensional array (scalar) of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">float value.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            return tensor(&x, null, dtype, device, requires_grad);
        }

        /// <summary>
        /// Converts a specified standard 1-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 2-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 3-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 4-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 5-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 6-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 7-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 8-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 9-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 10-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 11-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 12-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 13-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 14-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 15-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 16-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 17-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 18-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 19-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 20-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 21-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 22-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 23-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 24-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 25-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 26-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 27-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 28-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 29-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 30-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 31-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 32-dimensional array of the float type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor tensor(float[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(float* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30),
                                            x.GetLength(31)}, dtype, device, requires_grad);
            }
        }

        #endregion

        #region Tensor tensor(double[*] x, DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of a given data type, copies data from an array of type double to it
        /// by pointer x, interpreting it as multidimensional with dimensions size,
        /// places the tensor on the device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Pointer to array.</param>
        /// <param name="shape">The size of the array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient to the tensor.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double* x, int[] shape, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            if(dtype == DType.@default)
            {
                dtype = torch.float64;
            }
            var t = new Tensor(shape, dtype, device, requires_grad);
            t.device.__backend.convert(x, t.storage);
            return t;
        }

        /// <summary>
        /// Converts a specified standard 0-dimensional array (scalar) of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">double value.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            return tensor(&x, null, dtype, device, requires_grad);
        }

        /// <summary>
        /// Converts a specified standard 1-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 2-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 3-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 4-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 5-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 6-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 7-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 8-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 9-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 10-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 11-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 12-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 13-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 14-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 15-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 16-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 17-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 18-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 19-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 20-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 21-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 22-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 23-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 24-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 25-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 26-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 27-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 28-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 29-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 30-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 31-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 32-dimensional array of the double type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(double[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(double* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30),
                                            x.GetLength(31)}, dtype, device, requires_grad);
            }
        }

        #endregion

        #region Tensor tensor(CQuarter[*] x, DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of a given data type, copies data from an array of type CQuarter to it
        /// by pointer x, interpreting it as multidimensional with dimensions size,
        /// places the tensor on the device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Pointer to array.</param>
        /// <param name="shape">The size of the array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient to the tensor.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter* x, int[] shape, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            if(dtype == DType.@default)
            {
                dtype = torch.complex16;
            }
            if((dtype != torch.complex16) &&
               (dtype != torch.complex32) &&
               (dtype != torch.bcomplex32) &&
               (dtype != torch.complex64) &&
               (dtype != torch.complex128))
            {
                warnings.warn("The conversion of a complex number to a non-complex one leads to the loss of the imaginary part.");
            }
            var t = new Tensor(shape, dtype, device, requires_grad);
            t.device.__backend.convert(x, t.storage);
            return t;
        }

        /// <summary>
        /// Converts a specified standard 0-dimensional array (scalar) of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">System.CQuarter value.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            return tensor(&x, null, dtype, device, requires_grad);
        }

        /// <summary>
        /// Converts a specified standard 1-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 2-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 3-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 4-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 5-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 6-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 7-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 8-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 9-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 10-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 11-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 12-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 13-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 14-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 15-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 16-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 17-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 18-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 19-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 20-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 21-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 22-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 23-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 24-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 25-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 26-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 27-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 28-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 29-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 30-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 31-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 32-dimensional array of the CQuarter type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CQuarter[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CQuarter* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30),
                                            x.GetLength(31)}, dtype, device, requires_grad);
            }
        }

        #endregion

        #region Tensor tensor(CHalf[*] x, DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of a given data type, copies data from an array of type CHalf to it
        /// by pointer x, interpreting it as multidimensional with dimensions size,
        /// places the tensor on the device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Pointer to array.</param>
        /// <param name="shape">The size of the array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient to the tensor.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf* x, int[] shape, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            if(dtype == DType.@default)
            {
                dtype = torch.complex32;
            }
            if((dtype != torch.complex16) &&
               (dtype != torch.complex32) &&
               (dtype != torch.bcomplex32) &&
               (dtype != torch.complex64) &&
               (dtype != torch.complex128))
            {
                warnings.warn("The conversion of a complex number to a non-complex one leads to the loss of the imaginary part.");
            }
            var t = new Tensor(shape, dtype, device, requires_grad);
            t.device.__backend.convert(x, t.storage);
            return t;
        }

        /// <summary>
        /// Converts a specified standard 0-dimensional array (scalar) of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">System.CHalf value.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            return tensor(&x, null, dtype, device, requires_grad);
        }

        /// <summary>
        /// Converts a specified standard 1-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 2-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 3-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 4-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 5-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 6-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 7-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 8-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 9-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 10-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 11-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 12-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 13-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 14-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 15-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 16-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 17-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 18-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 19-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 20-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 21-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 22-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 23-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 24-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 25-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 26-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 27-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 28-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 29-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 30-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 31-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 32-dimensional array of the CHalf type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CHalf[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CHalf* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30),
                                            x.GetLength(31)}, dtype, device, requires_grad);
            }
        }

        #endregion

        #region Tensor tensor(CBFloat16[*] x, DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of a given data type, copies data from an array of type CBFloat16 to it
        /// by pointer x, interpreting it as multidimensional with dimensions size,
        /// places the tensor on the device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Pointer to array.</param>
        /// <param name="shape">The size of the array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient to the tensor.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16* x, int[] shape, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            if(dtype == DType.@default)
            {
                dtype = torch.bcomplex32;
            }
            if((dtype != torch.complex16) &&
               (dtype != torch.complex32) &&
               (dtype != torch.bcomplex32) &&
               (dtype != torch.complex64) &&
               (dtype != torch.complex128))
            {
                warnings.warn("The conversion of a complex number to a non-complex one leads to the loss of the imaginary part.");
            }
            var t = new Tensor(shape, dtype, device, requires_grad);
            t.device.__backend.convert(x, t.storage);
            return t;
        }

        /// <summary>
        /// Converts a specified standard 0-dimensional array (scalar) of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">System.CBFloat16 value.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16 x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            return tensor(&x, null, dtype, device, requires_grad);
        }

        /// <summary>
        /// Converts a specified standard 1-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 2-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 3-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 4-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 5-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 6-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 7-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 8-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 9-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 10-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 11-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 12-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 13-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 14-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 15-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 16-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 17-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 18-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 19-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 20-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 21-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 22-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 23-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 24-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 25-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 26-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 27-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 28-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 29-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 30-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 31-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 32-dimensional array of the CBFloat16 type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CBFloat16[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CBFloat16* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30),
                                            x.GetLength(31)}, dtype, device, requires_grad);
            }
        }

        #endregion

        #region Tensor tensor(CFloat[*] x, DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of a given data type, copies data from an array of type CFloat to it
        /// by pointer x, interpreting it as multidimensional with dimensions size,
        /// places the tensor on the device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Pointer to array.</param>
        /// <param name="shape">The size of the array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient to the tensor.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat* x, int[] shape, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            if(dtype == DType.@default)
            {
                dtype = torch.complex64;
            }
            if((dtype != torch.complex16) &&
               (dtype != torch.complex32) &&
               (dtype != torch.bcomplex32) &&
               (dtype != torch.complex64) &&
               (dtype != torch.complex128))
            {
                warnings.warn("The conversion of a complex number to a non-complex one leads to the loss of the imaginary part.");
            }
            var t = new Tensor(shape, dtype, device, requires_grad);
            t.device.__backend.convert(x, t.storage);
            return t;
        }

        /// <summary>
        /// Converts a specified standard 0-dimensional array (scalar) of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">System.CFloat value.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            return tensor(&x, null, dtype, device, requires_grad);
        }

        /// <summary>
        /// Converts a specified standard 1-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 2-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 3-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 4-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 5-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 6-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 7-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 8-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 9-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 10-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 11-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 12-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 13-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 14-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 15-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 16-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 17-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 18-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 19-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 20-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 21-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 22-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 23-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 24-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 25-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 26-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 27-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 28-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 29-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 30-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 31-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 32-dimensional array of the CFloat type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CFloat[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CFloat* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30),
                                            x.GetLength(31)}, dtype, device, requires_grad);
            }
        }

        #endregion

        #region Tensor tensor(CDouble[*] x, DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of a given data type, copies data from an array of type CDouble to it
        /// by pointer x, interpreting it as multidimensional with dimensions size,
        /// places the tensor on the device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Pointer to array.</param>
        /// <param name="shape">The size of the array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient to the tensor.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble* x, int[] shape, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            if(dtype == DType.@default)
            {
                dtype = torch.complex128;
            }
            if((dtype != torch.complex16) &&
               (dtype != torch.complex32) &&
               (dtype != torch.bcomplex32) &&
               (dtype != torch.complex64) &&
               (dtype != torch.complex128))
            {
                warnings.warn("The conversion of a complex number to a non-complex one leads to the loss of the imaginary part.");
            }
            var t = new Tensor(shape, dtype, device, requires_grad);
            t.device.__backend.convert(x, t.storage);
            return t;
        }

        /// <summary>
        /// Converts a specified standard 0-dimensional array (scalar) of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">System.CDouble value.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            return tensor(&x, null, dtype, device, requires_grad);
        }

        /// <summary>
        /// Converts a specified standard 1-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 2-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 3-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 4-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 5-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 6-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 7-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 8-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 9-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 10-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 11-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 12-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 13-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 14-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 15-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 16-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 17-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 18-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 19-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 20-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 21-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 22-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 23-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 24-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 25-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 26-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 27-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 28-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 29-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 30-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 31-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 32-dimensional array of the CDouble type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(CDouble[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(CDouble* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30),
                                            x.GetLength(31)}, dtype, device, requires_grad);
            }
        }

        #endregion

        #region Tensor tensor(sbyte[*] x, DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of a given data type, copies data from an array of type sbyte to it
        /// by pointer x, interpreting it as multidimensional with dimensions size,
        /// places the tensor on the device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Pointer to array.</param>
        /// <param name="shape">The size of the array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient to the tensor.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte* x, int[] shape, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            if(dtype == DType.@default)
            {
                dtype = torch.int8;
            }
            var t = new Tensor(shape, dtype, device, requires_grad);
            t.device.__backend.convert(x, t.storage);
            return t;
        }

        /// <summary>
        /// Converts a specified standard 0-dimensional array (scalar) of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">sbyte value.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            return tensor(&x, null, dtype, device, requires_grad);
        }

        /// <summary>
        /// Converts a specified standard 1-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 2-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 3-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 4-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 5-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 6-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 7-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 8-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 9-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 10-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 11-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 12-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 13-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 14-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 15-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 16-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 17-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 18-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 19-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 20-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 21-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 22-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 23-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 24-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 25-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 26-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 27-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 28-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 29-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 30-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 31-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 32-dimensional array of the sbyte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(sbyte[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(sbyte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30),
                                            x.GetLength(31)}, dtype, device, requires_grad);
            }
        }

        #endregion

        #region Tensor tensor(byte[*] x, DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of a given data type, copies data from an array of type byte to it
        /// by pointer x, interpreting it as multidimensional with dimensions size,
        /// places the tensor on the device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Pointer to array.</param>
        /// <param name="shape">The size of the array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient to the tensor.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte* x, int[] shape, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            if(dtype == DType.@default)
            {
                dtype = torch.uint8;
            }
            var t = new Tensor(shape, dtype, device, requires_grad);
            t.device.__backend.convert(x, t.storage);
            return t;
        }

        /// <summary>
        /// Converts a specified standard 0-dimensional array (scalar) of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">byte value.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            return tensor(&x, null, dtype, device, requires_grad);
        }

        /// <summary>
        /// Converts a specified standard 1-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 2-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 3-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 4-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 5-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 6-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 7-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 8-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 9-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 10-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 11-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 12-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 13-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 14-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 15-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 16-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 17-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 18-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 19-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 20-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 21-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 22-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 23-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 24-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 25-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 26-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 27-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 28-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 29-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 30-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 31-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 32-dimensional array of the byte type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(byte[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(byte* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30),
                                            x.GetLength(31)}, dtype, device, requires_grad);
            }
        }

        #endregion

        #region Tensor tensor(short[*] x, DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of a given data type, copies data from an array of type short to it
        /// by pointer x, interpreting it as multidimensional with dimensions size,
        /// places the tensor on the device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Pointer to array.</param>
        /// <param name="shape">The size of the array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient to the tensor.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short* x, int[] shape, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            if(dtype == DType.@default)
            {
                dtype = torch.int16;
            }
            var t = new Tensor(shape, dtype, device, requires_grad);
            t.device.__backend.convert(x, t.storage);
            return t;
        }

        /// <summary>
        /// Converts a specified standard 0-dimensional array (scalar) of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">short value.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            return tensor(&x, null, dtype, device, requires_grad);
        }

        /// <summary>
        /// Converts a specified standard 1-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 2-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 3-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 4-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 5-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 6-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 7-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 8-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 9-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 10-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 11-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 12-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 13-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 14-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 15-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 16-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 17-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 18-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 19-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 20-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 21-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 22-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 23-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 24-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 25-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 26-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 27-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 28-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 29-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 30-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 31-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 32-dimensional array of the short type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(short[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(short* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30),
                                            x.GetLength(31)}, dtype, device, requires_grad);
            }
        }

        #endregion

        #region Tensor tensor(ushort[*] x, DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of a given data type, copies data from an array of type ushort to it
        /// by pointer x, interpreting it as multidimensional with dimensions size,
        /// places the tensor on the device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Pointer to array.</param>
        /// <param name="shape">The size of the array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient to the tensor.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort* x, int[] shape, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            if(dtype == DType.@default)
            {
                dtype = torch.uint16;
            }
            var t = new Tensor(shape, dtype, device, requires_grad);
            t.device.__backend.convert(x, t.storage);
            return t;
        }

        /// <summary>
        /// Converts a specified standard 0-dimensional array (scalar) of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">ushort value.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            return tensor(&x, null, dtype, device, requires_grad);
        }

        /// <summary>
        /// Converts a specified standard 1-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 2-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 3-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 4-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 5-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 6-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 7-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 8-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 9-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 10-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 11-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 12-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 13-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 14-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 15-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 16-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 17-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 18-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 19-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 20-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 21-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 22-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 23-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 24-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 25-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 26-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 27-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 28-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 29-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 30-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 31-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 32-dimensional array of the ushort type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ushort[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ushort* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30),
                                            x.GetLength(31)}, dtype, device, requires_grad);
            }
        }

        #endregion

        #region Tensor tensor(int[*] x, DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of a given data type, copies data from an array of type int to it
        /// by pointer x, interpreting it as multidimensional with dimensions size,
        /// places the tensor on the device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Pointer to array.</param>
        /// <param name="shape">The size of the array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient to the tensor.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int* x, int[] shape, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            if(dtype == DType.@default)
            {
                dtype = torch.int32;
            }
            var t = new Tensor(shape, dtype, device, requires_grad);
            t.device.__backend.convert(x, t.storage);
            return t;
        }

        /// <summary>
        /// Converts a specified standard 0-dimensional array (scalar) of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">int value.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            return tensor(&x, null, dtype, device, requires_grad);
        }

        /// <summary>
        /// Converts a specified standard 1-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 2-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 3-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 4-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 5-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 6-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 7-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 8-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 9-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 10-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 11-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 12-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 13-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 14-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 15-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 16-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 17-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 18-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 19-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 20-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 21-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 22-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 23-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 24-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 25-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 26-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 27-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 28-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 29-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 30-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 31-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 32-dimensional array of the int type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(int[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(int* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30),
                                            x.GetLength(31)}, dtype, device, requires_grad);
            }
        }

        #endregion

        #region Tensor tensor(uint[*] x, DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of a given data type, copies data from an array of type uint to it
        /// by pointer x, interpreting it as multidimensional with dimensions size,
        /// places the tensor on the device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Pointer to array.</param>
        /// <param name="shape">The size of the array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient to the tensor.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint* x, int[] shape, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            if(dtype == DType.@default)
            {
                dtype = torch.uint32;
            }
            var t = new Tensor(shape, dtype, device, requires_grad);
            t.device.__backend.convert(x, t.storage);
            return t;
        }

        /// <summary>
        /// Converts a specified standard 0-dimensional array (scalar) of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">uint value.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            return tensor(&x, null, dtype, device, requires_grad);
        }

        /// <summary>
        /// Converts a specified standard 1-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 2-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 3-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 4-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 5-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 6-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 7-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 8-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 9-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 10-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 11-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 12-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 13-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 14-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 15-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 16-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 17-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 18-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 19-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 20-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 21-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 22-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 23-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 24-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 25-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 26-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 27-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 28-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 29-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 30-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 31-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 32-dimensional array of the uint type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(uint[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(uint* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30),
                                            x.GetLength(31)}, dtype, device, requires_grad);
            }
        }

        #endregion

        #region Tensor tensor(long[*] x, DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of a given data type, copies data from an array of type long to it
        /// by pointer x, interpreting it as multidimensional with dimensions size,
        /// places the tensor on the device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Pointer to array.</param>
        /// <param name="shape">The size of the array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient to the tensor.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long* x, int[] shape, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            if(dtype == DType.@default)
            {
                dtype = torch.int64;
            }
            var t = new Tensor(shape, dtype, device, requires_grad);
            t.device.__backend.convert(x, t.storage);
            return t;
        }

        /// <summary>
        /// Converts a specified standard 0-dimensional array (scalar) of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">long value.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            return tensor(&x, null, dtype, device, requires_grad);
        }

        /// <summary>
        /// Converts a specified standard 1-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 2-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 3-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 4-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 5-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 6-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 7-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 8-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 9-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 10-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 11-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 12-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 13-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 14-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 15-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 16-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 17-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 18-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 19-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 20-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 21-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 22-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 23-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 24-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 25-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 26-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 27-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 28-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 29-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 30-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 31-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 32-dimensional array of the long type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(long[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(long* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30),
                                            x.GetLength(31)}, dtype, device, requires_grad);
            }
        }

        #endregion

        #region Tensor tensor(ulong[*] x, DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of a given data type, copies data from an array of type ulong to it
        /// by pointer x, interpreting it as multidimensional with dimensions size,
        /// places the tensor on the device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Pointer to array.</param>
        /// <param name="shape">The size of the array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient to the tensor.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong* x, int[] shape, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            if(dtype == DType.@default)
            {
                dtype = torch.uint64;
            }
            var t = new Tensor(shape, dtype, device, requires_grad);
            t.device.__backend.convert(x, t.storage);
            return t;
        }

        /// <summary>
        /// Converts a specified standard 0-dimensional array (scalar) of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">ulong value.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            return tensor(&x, null, dtype, device, requires_grad);
        }

        /// <summary>
        /// Converts a specified standard 1-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 2-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 3-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 4-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 5-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 6-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 7-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 8-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 9-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 10-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 11-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 12-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 13-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 14-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 15-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 16-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 17-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 18-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 19-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 20-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 21-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 22-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 23-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 24-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 25-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 26-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 27-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 28-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 29-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 30-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 31-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 32-dimensional array of the ulong type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(ulong[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(ulong* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30),
                                            x.GetLength(31)}, dtype, device, requires_grad);
            }
        }

        #endregion

        #region Tensor tensor(bool[*] x, DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of a given data type, copies data from an array of type bool to it
        /// by pointer x, interpreting it as multidimensional with dimensions size,
        /// places the tensor on the device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Pointer to array.</param>
        /// <param name="shape">The size of the array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient to the tensor.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool* x, int[] shape, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            if(dtype == DType.@default)
            {
                dtype = torch.@bool;
            }
            var t = new Tensor(shape, dtype, device, requires_grad);
            t.device.__backend.convert(x, t.storage);
            return t;
        }

        /// <summary>
        /// Converts a specified standard 0-dimensional array (scalar) of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">bool value.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            return tensor(&x, null, dtype, device, requires_grad);
        }

        /// <summary>
        /// Converts a specified standard 1-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 2-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 3-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 4-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 5-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 6-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 7-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 8-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 9-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 10-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 11-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 12-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 13-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 14-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 15-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 16-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 17-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 18-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 19-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 20-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 21-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 22-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 23-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 24-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 25-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 26-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 27-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 28-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 29-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 30-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 31-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30)}, dtype, device, requires_grad);
            }
        }

        /// <summary>
        /// Converts a specified standard 32-dimensional array of the bool type
        /// into a tensor of the specified type, places it on the specified device device and
        /// initializes the gradient, if necessary.
        /// </summary>
        /// <param name="x">Standard .NET array.</param>
        /// <param name="dtype">Target data type.</param>
        /// <param name="device">The target device.</param>
        /// <param name="requires_grad">Indicates whether the gradient needs to be initialized.</param>
        /// <returns>torch.Tensor object.</returns>
        public static Tensor tensor(bool[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,] x, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            fixed(bool* px = x)
            {
                return tensor(px, new int[]{x.GetLength(0),
                                            x.GetLength(1),
                                            x.GetLength(2),
                                            x.GetLength(3),
                                            x.GetLength(4),
                                            x.GetLength(5),
                                            x.GetLength(6),
                                            x.GetLength(7),
                                            x.GetLength(8),
                                            x.GetLength(9),
                                            x.GetLength(10),
                                            x.GetLength(11),
                                            x.GetLength(12),
                                            x.GetLength(13),
                                            x.GetLength(14),
                                            x.GetLength(15),
                                            x.GetLength(16),
                                            x.GetLength(17),
                                            x.GetLength(18),
                                            x.GetLength(19),
                                            x.GetLength(20),
                                            x.GetLength(21),
                                            x.GetLength(22),
                                            x.GetLength(23),
                                            x.GetLength(24),
                                            x.GetLength(25),
                                            x.GetLength(26),
                                            x.GetLength(27),
                                            x.GetLength(28),
                                            x.GetLength(29),
                                            x.GetLength(30),
                                            x.GetLength(31)}, dtype, device, requires_grad);
            }
        }

        #endregion

        #region Tensor zeros(int dim1, ..., DType dtype, Device device, bool requires_grad)

        /// <summary>
        /// Creates a tensor of the specified data type and size,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="size">The size of the tensor. If null, creates 0-dimensional tensor (scalar).</param>
        /// <param name="dtype">Data type.</param>
        /// <param name="device">Device.</param>
        /// <param name="requires_grad">Specifies whether the tensor should have a gradient.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(IList<int> size = null, DType dtype = DType.@default, Device device = null, bool requires_grad = false)
        {
            var t = new Tensor(size, dtype, device, requires_grad);
            t.device.__backend.zeros(t.storage);
            return t;
        }

        /// <summary>
        /// Creates a 1-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 2-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 3-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 4-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 5-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 6-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 7-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 8-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 9-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 10-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 11-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 12-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 13-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 14-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dim14">Fourteenth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   int dim14,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13,
                                   dim14},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 15-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dim14">Fourteenth dimension.</param>
        /// <param name="dim15">Fifteenth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   int dim14,
                                   int dim15,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13,
                                   dim14,
                                   dim15},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 16-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dim14">Fourteenth dimension.</param>
        /// <param name="dim15">Fifteenth dimension.</param>
        /// <param name="dim16">Sixteenth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   int dim14,
                                   int dim15,
                                   int dim16,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13,
                                   dim14,
                                   dim15,
                                   dim16},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 17-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dim14">Fourteenth dimension.</param>
        /// <param name="dim15">Fifteenth dimension.</param>
        /// <param name="dim16">Sixteenth dimension.</param>
        /// <param name="dim17">Seventeenth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   int dim14,
                                   int dim15,
                                   int dim16,
                                   int dim17,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13,
                                   dim14,
                                   dim15,
                                   dim16,
                                   dim17},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 18-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dim14">Fourteenth dimension.</param>
        /// <param name="dim15">Fifteenth dimension.</param>
        /// <param name="dim16">Sixteenth dimension.</param>
        /// <param name="dim17">Seventeenth dimension.</param>
        /// <param name="dim18">Eighteenth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   int dim14,
                                   int dim15,
                                   int dim16,
                                   int dim17,
                                   int dim18,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13,
                                   dim14,
                                   dim15,
                                   dim16,
                                   dim17,
                                   dim18},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 19-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dim14">Fourteenth dimension.</param>
        /// <param name="dim15">Fifteenth dimension.</param>
        /// <param name="dim16">Sixteenth dimension.</param>
        /// <param name="dim17">Seventeenth dimension.</param>
        /// <param name="dim18">Eighteenth dimension.</param>
        /// <param name="dim19">Nineteenth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   int dim14,
                                   int dim15,
                                   int dim16,
                                   int dim17,
                                   int dim18,
                                   int dim19,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13,
                                   dim14,
                                   dim15,
                                   dim16,
                                   dim17,
                                   dim18,
                                   dim19},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 20-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dim14">Fourteenth dimension.</param>
        /// <param name="dim15">Fifteenth dimension.</param>
        /// <param name="dim16">Sixteenth dimension.</param>
        /// <param name="dim17">Seventeenth dimension.</param>
        /// <param name="dim18">Eighteenth dimension.</param>
        /// <param name="dim19">Nineteenth dimension.</param>
        /// <param name="dim20">Twentieth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   int dim14,
                                   int dim15,
                                   int dim16,
                                   int dim17,
                                   int dim18,
                                   int dim19,
                                   int dim20,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13,
                                   dim14,
                                   dim15,
                                   dim16,
                                   dim17,
                                   dim18,
                                   dim19,
                                   dim20},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 21-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dim14">Fourteenth dimension.</param>
        /// <param name="dim15">Fifteenth dimension.</param>
        /// <param name="dim16">Sixteenth dimension.</param>
        /// <param name="dim17">Seventeenth dimension.</param>
        /// <param name="dim18">Eighteenth dimension.</param>
        /// <param name="dim19">Nineteenth dimension.</param>
        /// <param name="dim20">Twentieth dimension.</param>
        /// <param name="dim21">Twenty-first dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   int dim14,
                                   int dim15,
                                   int dim16,
                                   int dim17,
                                   int dim18,
                                   int dim19,
                                   int dim20,
                                   int dim21,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13,
                                   dim14,
                                   dim15,
                                   dim16,
                                   dim17,
                                   dim18,
                                   dim19,
                                   dim20,
                                   dim21},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 22-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dim14">Fourteenth dimension.</param>
        /// <param name="dim15">Fifteenth dimension.</param>
        /// <param name="dim16">Sixteenth dimension.</param>
        /// <param name="dim17">Seventeenth dimension.</param>
        /// <param name="dim18">Eighteenth dimension.</param>
        /// <param name="dim19">Nineteenth dimension.</param>
        /// <param name="dim20">Twentieth dimension.</param>
        /// <param name="dim21">Twenty-first dimension.</param>
        /// <param name="dim22">Twenty-second dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   int dim14,
                                   int dim15,
                                   int dim16,
                                   int dim17,
                                   int dim18,
                                   int dim19,
                                   int dim20,
                                   int dim21,
                                   int dim22,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13,
                                   dim14,
                                   dim15,
                                   dim16,
                                   dim17,
                                   dim18,
                                   dim19,
                                   dim20,
                                   dim21,
                                   dim22},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 23-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dim14">Fourteenth dimension.</param>
        /// <param name="dim15">Fifteenth dimension.</param>
        /// <param name="dim16">Sixteenth dimension.</param>
        /// <param name="dim17">Seventeenth dimension.</param>
        /// <param name="dim18">Eighteenth dimension.</param>
        /// <param name="dim19">Nineteenth dimension.</param>
        /// <param name="dim20">Twentieth dimension.</param>
        /// <param name="dim21">Twenty-first dimension.</param>
        /// <param name="dim22">Twenty-second dimension.</param>
        /// <param name="dim23">Twenty-third dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   int dim14,
                                   int dim15,
                                   int dim16,
                                   int dim17,
                                   int dim18,
                                   int dim19,
                                   int dim20,
                                   int dim21,
                                   int dim22,
                                   int dim23,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13,
                                   dim14,
                                   dim15,
                                   dim16,
                                   dim17,
                                   dim18,
                                   dim19,
                                   dim20,
                                   dim21,
                                   dim22,
                                   dim23},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 24-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dim14">Fourteenth dimension.</param>
        /// <param name="dim15">Fifteenth dimension.</param>
        /// <param name="dim16">Sixteenth dimension.</param>
        /// <param name="dim17">Seventeenth dimension.</param>
        /// <param name="dim18">Eighteenth dimension.</param>
        /// <param name="dim19">Nineteenth dimension.</param>
        /// <param name="dim20">Twentieth dimension.</param>
        /// <param name="dim21">Twenty-first dimension.</param>
        /// <param name="dim22">Twenty-second dimension.</param>
        /// <param name="dim23">Twenty-third dimension.</param>
        /// <param name="dim24">Twenty-fourth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   int dim14,
                                   int dim15,
                                   int dim16,
                                   int dim17,
                                   int dim18,
                                   int dim19,
                                   int dim20,
                                   int dim21,
                                   int dim22,
                                   int dim23,
                                   int dim24,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13,
                                   dim14,
                                   dim15,
                                   dim16,
                                   dim17,
                                   dim18,
                                   dim19,
                                   dim20,
                                   dim21,
                                   dim22,
                                   dim23,
                                   dim24},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 25-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dim14">Fourteenth dimension.</param>
        /// <param name="dim15">Fifteenth dimension.</param>
        /// <param name="dim16">Sixteenth dimension.</param>
        /// <param name="dim17">Seventeenth dimension.</param>
        /// <param name="dim18">Eighteenth dimension.</param>
        /// <param name="dim19">Nineteenth dimension.</param>
        /// <param name="dim20">Twentieth dimension.</param>
        /// <param name="dim21">Twenty-first dimension.</param>
        /// <param name="dim22">Twenty-second dimension.</param>
        /// <param name="dim23">Twenty-third dimension.</param>
        /// <param name="dim24">Twenty-fourth dimension.</param>
        /// <param name="dim25">Twenty-fifth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   int dim14,
                                   int dim15,
                                   int dim16,
                                   int dim17,
                                   int dim18,
                                   int dim19,
                                   int dim20,
                                   int dim21,
                                   int dim22,
                                   int dim23,
                                   int dim24,
                                   int dim25,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13,
                                   dim14,
                                   dim15,
                                   dim16,
                                   dim17,
                                   dim18,
                                   dim19,
                                   dim20,
                                   dim21,
                                   dim22,
                                   dim23,
                                   dim24,
                                   dim25},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 26-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dim14">Fourteenth dimension.</param>
        /// <param name="dim15">Fifteenth dimension.</param>
        /// <param name="dim16">Sixteenth dimension.</param>
        /// <param name="dim17">Seventeenth dimension.</param>
        /// <param name="dim18">Eighteenth dimension.</param>
        /// <param name="dim19">Nineteenth dimension.</param>
        /// <param name="dim20">Twentieth dimension.</param>
        /// <param name="dim21">Twenty-first dimension.</param>
        /// <param name="dim22">Twenty-second dimension.</param>
        /// <param name="dim23">Twenty-third dimension.</param>
        /// <param name="dim24">Twenty-fourth dimension.</param>
        /// <param name="dim25">Twenty-fifth dimension.</param>
        /// <param name="dim26">Twenty-sixth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   int dim14,
                                   int dim15,
                                   int dim16,
                                   int dim17,
                                   int dim18,
                                   int dim19,
                                   int dim20,
                                   int dim21,
                                   int dim22,
                                   int dim23,
                                   int dim24,
                                   int dim25,
                                   int dim26,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13,
                                   dim14,
                                   dim15,
                                   dim16,
                                   dim17,
                                   dim18,
                                   dim19,
                                   dim20,
                                   dim21,
                                   dim22,
                                   dim23,
                                   dim24,
                                   dim25,
                                   dim26},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 27-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dim14">Fourteenth dimension.</param>
        /// <param name="dim15">Fifteenth dimension.</param>
        /// <param name="dim16">Sixteenth dimension.</param>
        /// <param name="dim17">Seventeenth dimension.</param>
        /// <param name="dim18">Eighteenth dimension.</param>
        /// <param name="dim19">Nineteenth dimension.</param>
        /// <param name="dim20">Twentieth dimension.</param>
        /// <param name="dim21">Twenty-first dimension.</param>
        /// <param name="dim22">Twenty-second dimension.</param>
        /// <param name="dim23">Twenty-third dimension.</param>
        /// <param name="dim24">Twenty-fourth dimension.</param>
        /// <param name="dim25">Twenty-fifth dimension.</param>
        /// <param name="dim26">Twenty-sixth dimension.</param>
        /// <param name="dim27">Twenty-seventh dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   int dim14,
                                   int dim15,
                                   int dim16,
                                   int dim17,
                                   int dim18,
                                   int dim19,
                                   int dim20,
                                   int dim21,
                                   int dim22,
                                   int dim23,
                                   int dim24,
                                   int dim25,
                                   int dim26,
                                   int dim27,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13,
                                   dim14,
                                   dim15,
                                   dim16,
                                   dim17,
                                   dim18,
                                   dim19,
                                   dim20,
                                   dim21,
                                   dim22,
                                   dim23,
                                   dim24,
                                   dim25,
                                   dim26,
                                   dim27},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 28-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dim14">Fourteenth dimension.</param>
        /// <param name="dim15">Fifteenth dimension.</param>
        /// <param name="dim16">Sixteenth dimension.</param>
        /// <param name="dim17">Seventeenth dimension.</param>
        /// <param name="dim18">Eighteenth dimension.</param>
        /// <param name="dim19">Nineteenth dimension.</param>
        /// <param name="dim20">Twentieth dimension.</param>
        /// <param name="dim21">Twenty-first dimension.</param>
        /// <param name="dim22">Twenty-second dimension.</param>
        /// <param name="dim23">Twenty-third dimension.</param>
        /// <param name="dim24">Twenty-fourth dimension.</param>
        /// <param name="dim25">Twenty-fifth dimension.</param>
        /// <param name="dim26">Twenty-sixth dimension.</param>
        /// <param name="dim27">Twenty-seventh dimension.</param>
        /// <param name="dim28">Twenty-eighth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   int dim14,
                                   int dim15,
                                   int dim16,
                                   int dim17,
                                   int dim18,
                                   int dim19,
                                   int dim20,
                                   int dim21,
                                   int dim22,
                                   int dim23,
                                   int dim24,
                                   int dim25,
                                   int dim26,
                                   int dim27,
                                   int dim28,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13,
                                   dim14,
                                   dim15,
                                   dim16,
                                   dim17,
                                   dim18,
                                   dim19,
                                   dim20,
                                   dim21,
                                   dim22,
                                   dim23,
                                   dim24,
                                   dim25,
                                   dim26,
                                   dim27,
                                   dim28},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 29-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dim14">Fourteenth dimension.</param>
        /// <param name="dim15">Fifteenth dimension.</param>
        /// <param name="dim16">Sixteenth dimension.</param>
        /// <param name="dim17">Seventeenth dimension.</param>
        /// <param name="dim18">Eighteenth dimension.</param>
        /// <param name="dim19">Nineteenth dimension.</param>
        /// <param name="dim20">Twentieth dimension.</param>
        /// <param name="dim21">Twenty-first dimension.</param>
        /// <param name="dim22">Twenty-second dimension.</param>
        /// <param name="dim23">Twenty-third dimension.</param>
        /// <param name="dim24">Twenty-fourth dimension.</param>
        /// <param name="dim25">Twenty-fifth dimension.</param>
        /// <param name="dim26">Twenty-sixth dimension.</param>
        /// <param name="dim27">Twenty-seventh dimension.</param>
        /// <param name="dim28">Twenty-eighth dimension.</param>
        /// <param name="dim29">Twenty-ninth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   int dim14,
                                   int dim15,
                                   int dim16,
                                   int dim17,
                                   int dim18,
                                   int dim19,
                                   int dim20,
                                   int dim21,
                                   int dim22,
                                   int dim23,
                                   int dim24,
                                   int dim25,
                                   int dim26,
                                   int dim27,
                                   int dim28,
                                   int dim29,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13,
                                   dim14,
                                   dim15,
                                   dim16,
                                   dim17,
                                   dim18,
                                   dim19,
                                   dim20,
                                   dim21,
                                   dim22,
                                   dim23,
                                   dim24,
                                   dim25,
                                   dim26,
                                   dim27,
                                   dim28,
                                   dim29},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 30-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dim14">Fourteenth dimension.</param>
        /// <param name="dim15">Fifteenth dimension.</param>
        /// <param name="dim16">Sixteenth dimension.</param>
        /// <param name="dim17">Seventeenth dimension.</param>
        /// <param name="dim18">Eighteenth dimension.</param>
        /// <param name="dim19">Nineteenth dimension.</param>
        /// <param name="dim20">Twentieth dimension.</param>
        /// <param name="dim21">Twenty-first dimension.</param>
        /// <param name="dim22">Twenty-second dimension.</param>
        /// <param name="dim23">Twenty-third dimension.</param>
        /// <param name="dim24">Twenty-fourth dimension.</param>
        /// <param name="dim25">Twenty-fifth dimension.</param>
        /// <param name="dim26">Twenty-sixth dimension.</param>
        /// <param name="dim27">Twenty-seventh dimension.</param>
        /// <param name="dim28">Twenty-eighth dimension.</param>
        /// <param name="dim29">Twenty-ninth dimension.</param>
        /// <param name="dim30">Thirtieth dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   int dim14,
                                   int dim15,
                                   int dim16,
                                   int dim17,
                                   int dim18,
                                   int dim19,
                                   int dim20,
                                   int dim21,
                                   int dim22,
                                   int dim23,
                                   int dim24,
                                   int dim25,
                                   int dim26,
                                   int dim27,
                                   int dim28,
                                   int dim29,
                                   int dim30,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13,
                                   dim14,
                                   dim15,
                                   dim16,
                                   dim17,
                                   dim18,
                                   dim19,
                                   dim20,
                                   dim21,
                                   dim22,
                                   dim23,
                                   dim24,
                                   dim25,
                                   dim26,
                                   dim27,
                                   dim28,
                                   dim29,
                                   dim30},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 31-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dim14">Fourteenth dimension.</param>
        /// <param name="dim15">Fifteenth dimension.</param>
        /// <param name="dim16">Sixteenth dimension.</param>
        /// <param name="dim17">Seventeenth dimension.</param>
        /// <param name="dim18">Eighteenth dimension.</param>
        /// <param name="dim19">Nineteenth dimension.</param>
        /// <param name="dim20">Twentieth dimension.</param>
        /// <param name="dim21">Twenty-first dimension.</param>
        /// <param name="dim22">Twenty-second dimension.</param>
        /// <param name="dim23">Twenty-third dimension.</param>
        /// <param name="dim24">Twenty-fourth dimension.</param>
        /// <param name="dim25">Twenty-fifth dimension.</param>
        /// <param name="dim26">Twenty-sixth dimension.</param>
        /// <param name="dim27">Twenty-seventh dimension.</param>
        /// <param name="dim28">Twenty-eighth dimension.</param>
        /// <param name="dim29">Twenty-ninth dimension.</param>
        /// <param name="dim30">Thirtieth dimension.</param>
        /// <param name="dim31">Thirty-first dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   int dim14,
                                   int dim15,
                                   int dim16,
                                   int dim17,
                                   int dim18,
                                   int dim19,
                                   int dim20,
                                   int dim21,
                                   int dim22,
                                   int dim23,
                                   int dim24,
                                   int dim25,
                                   int dim26,
                                   int dim27,
                                   int dim28,
                                   int dim29,
                                   int dim30,
                                   int dim31,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13,
                                   dim14,
                                   dim15,
                                   dim16,
                                   dim17,
                                   dim18,
                                   dim19,
                                   dim20,
                                   dim21,
                                   dim22,
                                   dim23,
                                   dim24,
                                   dim25,
                                   dim26,
                                   dim27,
                                   dim28,
                                   dim29,
                                   dim30,
                                   dim31},
                         dtype,
                         device,
                         requires_grad);
        }

        /// <summary>
        /// Creates a 32-dimensional tensor of the specified data type,
        /// fills it with default values for the data type (zeros),
        /// places it on the specified device device and initializes the gradient, if necessary.
        /// </summary>
        /// <param name="dim1">First dimension.</param>
        /// <param name="dim2">Second dimension.</param>
        /// <param name="dim3">Third dimension.</param>
        /// <param name="dim4">Fourth dimension.</param>
        /// <param name="dim5">Fifth dimension.</param>
        /// <param name="dim6">Sixth dimension.</param>
        /// <param name="dim7">Seventh dimension.</param>
        /// <param name="dim8">Eighth dimension.</param>
        /// <param name="dim9">Ninth dimension.</param>
        /// <param name="dim10">Tenth dimension.</param>
        /// <param name="dim11">Eleventh dimension.</param>
        /// <param name="dim12">Twelfth dimension.</param>
        /// <param name="dim13">Thirteenth dimension.</param>
        /// <param name="dim14">Fourteenth dimension.</param>
        /// <param name="dim15">Fifteenth dimension.</param>
        /// <param name="dim16">Sixteenth dimension.</param>
        /// <param name="dim17">Seventeenth dimension.</param>
        /// <param name="dim18">Eighteenth dimension.</param>
        /// <param name="dim19">Nineteenth dimension.</param>
        /// <param name="dim20">Twentieth dimension.</param>
        /// <param name="dim21">Twenty-first dimension.</param>
        /// <param name="dim22">Twenty-second dimension.</param>
        /// <param name="dim23">Twenty-third dimension.</param>
        /// <param name="dim24">Twenty-fourth dimension.</param>
        /// <param name="dim25">Twenty-fifth dimension.</param>
        /// <param name="dim26">Twenty-sixth dimension.</param>
        /// <param name="dim27">Twenty-seventh dimension.</param>
        /// <param name="dim28">Twenty-eighth dimension.</param>
        /// <param name="dim29">Twenty-ninth dimension.</param>
        /// <param name="dim30">Thirtieth dimension.</param>
        /// <param name="dim31">Thirty-first dimension.</param>
        /// <param name="dim32">Thirty-second dimension.</param>
        /// <param name="dtype">The tensor data type.</param>
        /// <param name="device">The device on which the tensor will be placed.</param>
        /// <param name="requires_grad">Specifies whether to create a gradient for the tensor.</param>
        /// <returns>torch.Tensor object with zeros.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Tensor zeros(int dim1,
                                   int dim2,
                                   int dim3,
                                   int dim4,
                                   int dim5,
                                   int dim6,
                                   int dim7,
                                   int dim8,
                                   int dim9,
                                   int dim10,
                                   int dim11,
                                   int dim12,
                                   int dim13,
                                   int dim14,
                                   int dim15,
                                   int dim16,
                                   int dim17,
                                   int dim18,
                                   int dim19,
                                   int dim20,
                                   int dim21,
                                   int dim22,
                                   int dim23,
                                   int dim24,
                                   int dim25,
                                   int dim26,
                                   int dim27,
                                   int dim28,
                                   int dim29,
                                   int dim30,
                                   int dim31,
                                   int dim32,
                                   DType dtype = DType.@default,
                                   Device device = null,
                                   bool requires_grad = false)
        {
            return zeros(new int[]{dim1,
                                   dim2,
                                   dim3,
                                   dim4,
                                   dim5,
                                   dim6,
                                   dim7,
                                   dim8,
                                   dim9,
                                   dim10,
                                   dim11,
                                   dim12,
                                   dim13,
                                   dim14,
                                   dim15,
                                   dim16,
                                   dim17,
                                   dim18,
                                   dim19,
                                   dim20,
                                   dim21,
                                   dim22,
                                   dim23,
                                   dim24,
                                   dim25,
                                   dim26,
                                   dim27,
                                   dim28,
                                   dim29,
                                   dim30,
                                   dim31,
                                   dim32},
                         dtype,
                         device,
                         requires_grad);
        }

        #endregion

        #region Tensor <operation>(Tensor x)

        public static Tensor abs(this Tensor x)
        {
            var y = new Tensor(x.shape, (x.dtype == torch.complex16) ? torch.float8 : ((x.dtype == torch.complex32) ? torch.float16 : ((x.dtype == torch.bcomplex32) ? torch.bfloat16 : ((x.dtype == torch.complex64) ? torch.float32 : ((x.dtype == torch.complex128) ? torch.float64 : x.dtype)))), x.device, x.requires_grad);
            try
            {
                x.device.__backend.abs(x.storage, y.storage);
            }
            catch(Exception e)
            {
                throw e;
            }
            if(y.requires_grad)
            {
                var y_storage = y.storage;
                var x_storage = x.storage;
                y.backward_fn = () =>
                {
                    x.device.__backend.abs_backward(x_storage, x.grad.storage, y_storage, y.grad.storage);
                    if(x.backward_fn != null)
                    {
                        x.backward_fn();
                    }
                };
                y.grad_fn = "AbsBackward";
            }
            return y;
        }

        public static Tensor sin(this Tensor x)
        {
            var y = new Tensor(x.shape, x.dtype, x.device, x.requires_grad);
            try
            {
                x.device.__backend.sin(x.storage, y.storage);
            }
            catch(Exception e)
            {
                throw e;
            }
            if(y.requires_grad)
            {
                var x_storage = x.storage;
                y.backward_fn = () =>
                {
                    x.device.__backend.sin_backward(x_storage, x.grad.storage, y.grad.storage);
                    if(x.backward_fn != null)
                    {
                        x.backward_fn();
                    }
                };
                y.grad_fn = "SinBackward";
            }
            return y;
        }

        public static Tensor cos(this Tensor x)
        {
            var y = new Tensor(x.shape, x.dtype, x.device, x.requires_grad);
            try
            {
                x.device.__backend.cos(x.storage, y.storage);
            }
            catch(Exception e)
            {
                throw e;
            }
            if(y.requires_grad)
            {
                var x_storage = x.storage;
                y.backward_fn = () =>
                {
                    x.device.__backend.cos_backward(x_storage, x.grad.storage, y.grad.storage);
                    if(x.backward_fn != null)
                    {
                        x.backward_fn();
                    }
                };
                y.grad_fn = "CosBackward";
            }
            return y;
        }

        #endregion

    }

}